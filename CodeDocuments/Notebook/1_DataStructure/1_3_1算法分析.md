# 1.3 算法分析

## 1.3.1 概述

**算法分析**就是分析算法对计算机资源占用程度  

## 1.3.2 算法时间性能分析

### 1. 两种分析方式

1. 事后统计法  
编写算法对应程序，统计执行时间  
缺点：

   1) 必须执行程序  
   2) 很多因素会掩盖算法本质  
2. 事前估算法  
仅考虑算法本身的效率高低  
可认为一个特性算法的“运行工作量大小”只依赖于问题规模(一般表示为整数n)  
可以将算法执行时间看成问题规模的函数  

### 2. 算法时间复杂度分析

1. 计算算法的频度 $T(n)$  
    $算法 = 控制结构 + 原操作$  
    其中：  
    **控制结构**包括 顺序 分支 循环 共三种  
    **原操作**即固有数据类型的操作  
    具体可以参考[实例1](1_3_2eg.md#实例1)  

    算法执行时间受 控制结构 和 原操作 的综合影响  
    一个算法的执行时间可以有原操作的**执行次数**来计量  
    算法时间分析即求出算法所有原操作的执行次数(也就是**频度**)  
    [例题1](1_3_2eg.md#eg-31)  
2. $T(n)$ 用"O"表示  
    算法分析不注重绝对时间的分析  
    通常进一步采用时间复杂度来表示  
    算法**时间复杂度**以 $T(n)$ 的数量级来表示  
    记作 $T(n) = O(f(n))$  
    此处O表Order(数量级)  
    此处不对严格数学定义进行阐述  
    一般只求出 $T(n)$ 的最高阶，而忽略其低阶项 and 常数项  
    以达到足够准确描述  $n$ 较大时的时间性能的同时简化计算  

    一般，没有循环 or 循环与问题规模n无关 的算法，原操作执行次数与问题规模n无关，记作 $O(1)$ (常数阶)  
    *算法中每个简单语句执行时间均看作 $O(1)$*  
    一个只有一重循环的算法，原操作执行次数与问题规模 $n$ 的增长呈线性增大关系，记作 $O(n)$ (线性阶)  
    常见的还有几个，存在以下关系  
    $O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)$  
    类似第2-6项的称**多项式时间复杂度**  
    类似之后的称**指数时间复杂度**  

3. 简化的算法时间复杂度分析  
    仅考虑算法中基本操作的分析方法  
    **基本操作**指算法中最深层循环内的原操作  
    *这是此后主要采用的方式*  
    [例题2](1_3_2eg.md#eg-32)  
4. 时间复杂度的求和 and 求积 定理  
    **求和定理**  
    取最大的时间复杂度  
    *例如多个并列循环*  

    **求积定理**  
    $T_1(n)=O(f(n)),T_2(n)=O(g(n))$  
    那么 $T_1(n)\times T_2(n)=O(f(n)\times g(n))$  
    *例如多层嵌套循环*  

### 3. 算法得最好、最坏和平均时间复杂度

### 4. 递归算法时间复杂度分析
